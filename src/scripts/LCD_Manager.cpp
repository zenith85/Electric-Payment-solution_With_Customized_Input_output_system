#include <Arduino.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Adafruit_SSD1306.h>
#include "LCD_Manager.h"
#include "TasksManager.h"
#include "DEF_TECH_INT.h"

using namespace LCD_DISPLAY;

TasksManager_class TM_LCD_manager;

LCDPage EnumOfIndex(int i) { return static_cast<LCDPage>(i); }
LCDPage PAGE = state;
int PAGE_sel = 1;
String PAGE_NAMES[LCDPage_end + 1] = {"begin", "state", "GPS information Data", "NFC Information Data", "end"};

#ifdef LCD_1602
LiquidCrystal_I2C lcd(0x27, 16, 3);
// LiquidCrystal_I2C lcd(0x0f, 16, 3);
byte c1[] = {
    0x00,
    0x00,
    0x00,
    0x07,
    0x0F,
    0x0E,
    0x0E,
    0x0E};
byte c2[] = {
    0x00,
    0x00,
    0x00,
    0x1F,
    0x1F,
    0x00,
    0x00,
    0x00};
byte c3[] = {
    0x0E,
    0x0E,
    0x0E,
    0x0E,
    0x0E,
    0x0E,
    0x0E,
    0x0E};
byte c4[] = {
    0x0E,
    0x0E,
    0x0E,
    0x0F,
    0x07,
    0x00,
    0x00,
    0x00};
byte c5[] = {
    0x0E,
    0x0E,
    0x0E,
    0x1E,
    0x1C,
    0x00,
    0x00,
    0x00};
byte c6[] = {
    0x00,
    0x00,
    0x00,
    0x1C,
    0x1E,
    0x0E,
    0x0E,
    0x0E};
byte c7[] = {
    0x1B,
    0x1F,
    0x1F,
    0x0E,
    0x0E,
    0x0E,
    0x0E,
    0x0E};
byte c8[] = {
    0x1F,
    0x1F,
    0x1F,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00};
byte *logo[] = {c1, c2, c3, c4, c5, c6, c7, c8};

void LCD_DISPLAY_class::LCD_init()
{
  pinMode(pagerPin, INPUT);

  lcd.init();
  lcd.begin(16, 3);
  lcd.backlight();
  lcd.clear();
  for (int i = 0; i < 8; i++)
  {
    lcd.createChar(i, logo[i]);
  }
  for (int i = 2; i < 7; i++)
  {
    lcd.setCursor(i, 0);
    lcd.write((byte)1);
    lcd.setCursor(i, 3);
    lcd.write((byte)1);
  }
  for (int i = 1; i < 3; i++)
  {
    lcd.setCursor(1, i);
    lcd.write((byte)2);
    lcd.setCursor(7, i);
    lcd.write((byte)2);
  }
  lcd.setCursor(4, 2);
  lcd.write((byte)2);
  lcd.setCursor(3, 1);
  lcd.write((byte)7);
  lcd.setCursor(5, 1);
  lcd.write((byte)7);
  lcd.setCursor(4, 1);
  lcd.write((byte)6);
  lcd.setCursor(1, 0);
  lcd.write((byte)0);
  lcd.setCursor(1, 3);
  lcd.write((byte)3);
  lcd.setCursor(7, 0);
  lcd.write((byte)5);
  lcd.setCursor(7, 3);
  lcd.write((byte)4);

  lcd.setCursor(9, 1);
  lcd.print("ALTAMEER");
  lcd.setCursor(9, 2);
  lcd.print("Systems");
  for (int i = 0; i < 8; i++)
  {
    vTaskDelay(200 / portTICK_PERIOD_MS);
    lcd.setCursor(9 + i, 3);
    lcd.print("*");
  }
  // lcd.scrollDisplayLeft();
  lcd.clear();
  // add this at begining of screen to display the first page
  lcd.setCursor(0, FIRSTROW);
  lcd.print(PAGE_NAMES[EnumOfIndex(PAGE)]);
}
void LCD_DISPLAY_class::Page_selector()
{
  vTaskDelay(500 / portTICK_PERIOD_MS);
  while (digitalRead(pagerPin) == HIGH)
  {
    TM_LCD_manager.TasksManager_Suspend_Tasks();
    {
      while (digitalRead(pagerPin) == HIGH)
      {
        lcd.clear();
        lcd.setCursor(0, FIRSTROW);
        PAGE_sel++;
        PAGE = EnumOfIndex(PAGE_sel);
        Serial.println(PAGE);
        vTaskDelay(200 / portTICK_PERIOD_MS);
        lcd.print(PAGE_NAMES[EnumOfIndex(PAGE)]);
        vTaskDelay(200 / portTICK_PERIOD_MS);

        if (EnumOfIndex(PAGE_sel) == LCDPage_end - 1)
        {
          PAGE_sel = 0;
        }
      }
      TM_LCD_manager.TasksManager_Resume_Tasks();
    }
  }
}
// class for display trouble shooting problem
// TS display start at zero
void LCD_DISPLAY_class::TS_Display(String text, TS_Code TSC, LCDPage PAGE_)
{
  if (PAGE_ == PAGE)
  {
    // vTaskDelay(500 / portTICK_PERIOD_MS);
    lcd.setCursor(0, TSC);
    lcd.print(text);
  }
}
// TS display constume starting point
void LCD_DISPLAY_class::TS_Display(String text, TS_Code TSC, LCDPage PAGE_, uint8_t curloc)
{
  if (PAGE_ == PAGE)
  {
    // vTaskDelay(500 / portTICK_PERIOD_MS);
    lcd.setCursor(curloc, TSC);
    lcd.print(text);
  }
}
#endif

#ifdef SSD1306
// '', 64x64px
const unsigned char epd_bitmap_ [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x80, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x07, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xe0, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x1f, 0xfe, 0x00, 0x00, 
	0x00, 0x03, 0xff, 0xf8, 0x3f, 0xff, 0xf0, 0x00, 0x00, 0x3f, 0xff, 0xf8, 0x1f, 0xff, 0xfc, 0x00, 
	0x00, 0x3f, 0xff, 0x80, 0x00, 0xff, 0xf8, 0x00, 0x01, 0x1f, 0xfc, 0x00, 0x00, 0x6f, 0xf1, 0x00, 
	0x01, 0x8f, 0x84, 0x00, 0x00, 0x60, 0x63, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x00, 0x20, 0x07, 0x80, 
	0x01, 0xe0, 0x0c, 0x00, 0x00, 0x20, 0x0f, 0x80, 0x01, 0xe0, 0x0c, 0x00, 0x00, 0x30, 0x0f, 0x80, 
	0x03, 0xe0, 0x0c, 0x00, 0x00, 0x70, 0x07, 0x80, 0x03, 0xe0, 0x0e, 0x00, 0x00, 0xf0, 0x07, 0xc0, 
	0x03, 0xe0, 0x0f, 0x00, 0x01, 0xe0, 0x07, 0xc0, 0x03, 0xc0, 0x07, 0x80, 0x03, 0xc0, 0x07, 0xc0, 
	0x07, 0xc0, 0x03, 0xc0, 0x07, 0x80, 0x03, 0xc0, 0x07, 0xc0, 0x01, 0xf8, 0x3f, 0x01, 0xc3, 0xe0, 
	0x07, 0xcf, 0x80, 0xfc, 0x3e, 0x03, 0xff, 0xe0, 0x07, 0xbf, 0xc0, 0x7e, 0x7e, 0x07, 0xff, 0xf0, 
	0x0f, 0xc1, 0xe0, 0x7c, 0x7e, 0x0f, 0x81, 0xfe, 0x7f, 0x80, 0xf0, 0x7c, 0x3c, 0x1f, 0x01, 0xfc, 
	0x3f, 0x80, 0x78, 0x38, 0x18, 0x1e, 0x01, 0xf8, 0x1f, 0x80, 0x3f, 0x00, 0x00, 0xfc, 0x01, 0xf0, 
	0x0f, 0x00, 0x1f, 0x80, 0x01, 0xf8, 0x00, 0xe0, 0x07, 0x00, 0x1f, 0x81, 0x81, 0xf8, 0x00, 0xc0, 
	0x03, 0x00, 0x1f, 0x83, 0xc1, 0xf0, 0x00, 0xc0, 0x01, 0x00, 0x0f, 0x07, 0xe0, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x06, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x0f, 0xf0, 0xf0, 0x00, 0x00, 
	0x01, 0x00, 0x0f, 0x87, 0xe1, 0xf0, 0x00, 0xc0, 0x03, 0x00, 0x0f, 0x83, 0xc1, 0xf8, 0x00, 0xe0, 
	0x07, 0x00, 0x0f, 0x80, 0x81, 0xf8, 0x00, 0xf0, 0x0f, 0x00, 0x1f, 0x80, 0x00, 0xfc, 0x00, 0xf8, 
	0x1f, 0x80, 0x3f, 0x00, 0x00, 0x7e, 0x01, 0xfc, 0x3f, 0x80, 0x78, 0x3c, 0x3c, 0x0f, 0x01, 0xfe, 
	0x7f, 0x80, 0xf0, 0x7e, 0x3e, 0x07, 0x81, 0xfe, 0x3f, 0xc1, 0xe0, 0x7e, 0x3e, 0x03, 0xff, 0xf0, 
	0x07, 0xff, 0xc0, 0x7e, 0x3e, 0x01, 0xff, 0xe0, 0x07, 0xdf, 0x80, 0xfc, 0x3f, 0x00, 0xc3, 0xe0, 
	0x03, 0xc0, 0x01, 0xf8, 0x07, 0x80, 0x03, 0xe0, 0x03, 0xc0, 0x03, 0xc0, 0x03, 0xe0, 0x03, 0xe0, 
	0x03, 0xe0, 0x07, 0x80, 0x01, 0xe0, 0x03, 0xc0, 0x03, 0xe0, 0x0f, 0x00, 0x00, 0xf0, 0x07, 0xc0, 
	0x01, 0xe0, 0x0e, 0x00, 0x00, 0x70, 0x07, 0xc0, 0x01, 0xe0, 0x0e, 0x00, 0x00, 0x30, 0x07, 0xc0, 
	0x01, 0xf0, 0x0c, 0x00, 0x00, 0x30, 0x07, 0x80, 0x01, 0xf0, 0x04, 0x00, 0x00, 0x30, 0x03, 0x80, 
	0x00, 0xe0, 0x06, 0x00, 0x00, 0x30, 0x31, 0x80, 0x00, 0xcf, 0x86, 0x00, 0x00, 0x23, 0xf8, 0x80, 
	0x00, 0x9f, 0xfe, 0x00, 0x00, 0x7f, 0xfc, 0x00, 0x00, 0x3f, 0xff, 0xc0, 0x03, 0xff, 0xfe, 0x00, 
	0x00, 0x3f, 0xff, 0xfc, 0x1f, 0xff, 0xf0, 0x00, 0x00, 0x03, 0xff, 0xf8, 0x1f, 0xff, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xf8, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x07, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xe0, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Charging Sign', 20x20px
const unsigned char epd_Charging_Sign [] PROGMEM = {
	// 'CS, 20x20px
	0x07, 0x0e, 0x00, 0x05, 0x0a, 0x00, 0x05, 0x0a, 0x00, 0x05, 0x0a, 0x00, 0x1f, 0xff, 0x80, 0x20, 
	0x00, 0x40, 0x20, 0x00, 0x40, 0x27, 0xfe, 0x40, 0x27, 0xfe, 0x40, 0x27, 0xfe, 0x40, 0x27, 0xfe, 
	0x40, 0x27, 0xfe, 0x40, 0x20, 0x00, 0x40, 0x30, 0x00, 0xc0, 0x0f, 0xff, 0x00, 0x00, 0x70, 0x00, 
	0x00, 0x70, 0x00, 0x00, 0x70, 0x00, 0x00, 0x7f, 0x80, 0x00, 0x7f, 0x80
};
// 'No_Charging_sign', 20x20px
const unsigned char epd_No_Charging_sign [] PROGMEM = {
	0x07, 0x0e, 0x40, 0x05, 0x0a, 0x80, 0x05, 0x0b, 0x00, 0x05, 0x0a, 0x10, 0x1f, 0xfc, 0x20, 0x20, 
	0x08, 0x40, 0x20, 0x10, 0xc0, 0x27, 0xe1, 0x40, 0x27, 0xc2, 0x40, 0x27, 0x86, 0x40, 0x27, 0x0e, 
	0x40, 0x26, 0x1e, 0x40, 0x24, 0x20, 0x40, 0x38, 0x40, 0xc0, 0x10, 0xff, 0x00, 0x21, 0x70, 0x00, 
	0x42, 0x70, 0x00, 0x84, 0x70, 0x00, 0x08, 0x7f, 0x80, 0x10, 0x7f, 0x80
};
// 'Wifi_On', 20x20px
const unsigned char epd_bitmap_Wifi_On [] PROGMEM = {
	0x00, 0x00, 0x00, 0x70, 0x00, 0xc0, 0x50, 0x01, 0x80, 0xd0, 0x03, 0x00, 0xd0, 0x36, 0x00, 0xd3, 
	0x9c, 0x00, 0x52, 0x88, 0x00, 0x56, 0x80, 0x00, 0x56, 0x80, 0x00, 0x56, 0x9c, 0x00, 0x52, 0x94, 
	0x00, 0x52, 0xb4, 0x00, 0x52, 0xb4, 0xe0, 0x52, 0xb4, 0x00, 0x52, 0x95, 0xe0, 0x52, 0x95, 0xa0, 
	0x52, 0x95, 0xa0, 0x52, 0x94, 0xe0, 0x73, 0x9c, 0xe0, 0x00, 0x00, 0x00
};
// 'Wifi_Off', 20x20px
const unsigned char epd_bitmap_Wifi_Off [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x08, 0x40, 0x00, 0x14, 0xa0, 0x00, 0x0b, 0x40, 0x00, 0x06, 0x80, 0x00, 
	0x05, 0x80, 0x00, 0x0b, 0x40, 0x00, 0x14, 0xa0, 0x00, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0xf7, 0xbd, 0xe0, 0xd6, 0xb5, 0xa0, 
	0xd6, 0xb5, 0xa0, 0x52, 0x94, 0xe0, 0x73, 0x9c, 0xe0, 0x00, 0x00, 0x00
};

// 'drawlogo', 30x30px
const unsigned char epd_bitmap_drawlogo [] PROGMEM  = {
	0x00, 0x20, 0x00, 0x00, 0x00, 0x30, 0x70, 0x00, 0x00, 0xf8, 0xfc, 0x00, 0x07, 0xfc, 0xff, 0x80, 
	0x07, 0xe0, 0x1f, 0xc0, 0x1a, 0x40, 0x00, 0xe0, 0x1c, 0x40, 0x08, 0xe0, 0x18, 0x60, 0x10, 0x60, 
	0x38, 0x30, 0x20, 0x70, 0x3b, 0x1c, 0xe3, 0xf0, 0x79, 0x8c, 0xc6, 0x78, 0x78, 0xc8, 0x0c, 0x78, 
	0x30, 0x70, 0x18, 0x30, 0x10, 0x63, 0x18, 0x20, 0x00, 0x07, 0x80, 0x00, 0x00, 0x07, 0x80, 0x00, 
	0x10, 0x73, 0x38, 0x30, 0x30, 0x70, 0x1c, 0x38, 0x78, 0xc4, 0xcc, 0x78, 0x79, 0x8c, 0xc3, 0x78, 
	0x3f, 0x1c, 0xe1, 0x70, 0x18, 0x30, 0x30, 0x70, 0x1c, 0x60, 0x18, 0x60, 0x1c, 0x40, 0x08, 0x60, 
	0x1e, 0x00, 0x0b, 0xe0, 0x0f, 0xf0, 0x3f, 0xc0, 0x07, 0xfc, 0xff, 0x80, 0x00, 0x7c, 0x78, 0x00, 
	0x00, 0x38, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00
};

#define SCREEN_WIDTH 128    // OLED display width, in pixels
#define SCREEN_HEIGHT 64    // OLED display height, in pixels
#define OLED_RESET -1       // Reset pin # (or -1 if sharing MCU reset pin)
#define SCREEN_ADDRESS 0x3C ///< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32
#define YPixelrow 16
#define charwidth 6

Adafruit_SSD1306 oled(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
// Adafruit_SSD1306 oled(OLED_RESET);

int FindWordWidth(String word, int fontsize)
{
  return word.length() * charwidth * fontsize;
}
void Cprint(String word, int fontsize, int row)
{
  oled.setTextColor(WHITE);
  oled.setTextSize(fontsize);
  oled.setCursor(SCREEN_WIDTH / 2 - FindWordWidth(word, fontsize) / 2, row);
  oled.print(word);
  oled.display();
}
void Jprint(String word, TS_FontStyle fontstyle[], int row, int col, int color)
{
  int x=fontstyle[0];int y= fontstyle[1];
  oled.setTextSize(x,y);
  oled.setTextColor(color);
  oled.setCursor(col, row);
  oled.print(word);
  oled.display();
}
void LCD_DISPLAY_class::fullerase()
{
  oled.clearDisplay();
}

void LCD_DISPLAY_class::LCD_init()
{
  Wire.begin();
  pinMode(pagerPin, INPUT);
  if (!oled.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS))
  {
    Serial.println(F("SSD1306 allocation failed"));
    for (;;)
      ; // Don't proceed, loop forever
  }
  fullerase();
  oled.drawBitmap(32,0,epd_bitmap_,64,64,WHITE);
  oled.display();
  delay(2000);
  fullerase();
  oled.drawBitmap(49,0,epd_bitmap_drawlogo,30,30,WHITE);
  oled.setTextColor(WHITE);
  Cprint("ALTAMEER", FontMedium, 31);
  Cprint("Systems. CIOS", FontSmall, 46);
  oled.drawRect(30, 56, 68, 8, SSD1306_WHITE);
  oled.display();
}
//loading bar is directly connected with the MCIOS, loading memory impacting the loading speed
bool LCD_DISPLAY_class::Loading_Bar(uint8_t v)
{
  uint8_t segment=SCREEN_WIDTH/16;
  //for (int16_t i = segment*(v-32); i < (segment*v) ; i = i + 4)
  for (int16_t i = (segment*v)+31; i < (segment*v)+32+segment ; i = i + 2)
  {
    for (int16_t j = 0; j < 4; j++)
    {
      oled.drawPixel(i, 58 + j, SSD1306_WHITE);
      oled.display();
    }
  }
  return 1;
}

void LCD_DISPLAY_class::Charging_Symbol(boolean v)
{
  if (!v){
    oled.drawBitmap(108,1,epd_Charging_Sign,20,20,BLACK);
    oled.drawBitmap(108,1,epd_No_Charging_sign,20,20,WHITE);
  }else{
    oled.drawBitmap(108,1,epd_No_Charging_sign,20,20,BLACK);
    oled.drawBitmap(108,1,epd_Charging_Sign,20,20,WHITE);
  }
  oled.display();
}

void LCD_DISPLAY_class::Wifi_Symbol(boolean v)
{
  if (!v){
    oled.drawBitmap(88,1,epd_bitmap_Wifi_On,19,19,BLACK);
    oled.drawBitmap(88,1,epd_bitmap_Wifi_Off,19,19,WHITE);
  }else{
    oled.drawBitmap(88,1,epd_bitmap_Wifi_Off,19,19,BLACK);
    oled.drawBitmap(88,1,epd_bitmap_Wifi_On,19,19,WHITE);
  }
  oled.display();
}

void LCD_DISPLAY_class::Page_selector()
{
  vTaskDelay(500 / portTICK_PERIOD_MS);
  while (digitalRead(pagerPin) == HIGH)
  {
    TM_LCD_manager.TasksManager_Suspend_Tasks();
    {
      while (digitalRead(pagerPin) == HIGH)
      {
        if (EnumOfIndex(PAGE_sel) == LCDPage_end - 1)
        {
          PAGE_sel = 0;
        }
      }
      TM_LCD_manager.TasksManager_Resume_Tasks();
    }
  }
}
// class for display trouble shooting problem
// TS display start at zero
void LCD_DISPLAY_class::TS_Display(String text, TS_Code TSC, LCDPage PAGE_)
{
  //oled.clearDisplay();
  //Jprint(PAGE_NAMES[EnumOfIndex(PAGE)],1,0, FIRSTROW*YPixelrow);
  if (PAGE_ == PAGE)
  {
    //Jprint(text,regular_small,TSC*YPixelrow,0,WHITE);
  }
}
// TS display constume starting point
void LCD_DISPLAY_class::TS_Display(String text, TS_Code TSC, LCDPage PAGE_, uint8_t curloc)
{
  if (PAGE_ == PAGE)
  {
    Jprint(text,TS_regular_small,TSC*YPixelrow,curloc, WHITE);
  }
}
// Either write or delete the line, parital clear implementation
void LCD_DISPLAY_class::TS_Display(String text, TS_FontStyle fontstyle[], TS_Code TSC, LCDPage PAGE_, uint8_t curloc, boolean WRORDEL)
{
  if (PAGE_ == PAGE)
  {
    if (WRORDEL)
    {
      Jprint(text,fontstyle,TSC*YPixelrow,curloc, WHITE);
    }else{
      Jprint(text,fontstyle,TSC*YPixelrow,curloc, BLACK);
    }    
  }
}
#endif